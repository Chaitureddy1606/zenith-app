//
//  FinanceManager.swift
//  app-ai
//
//  Created by chaitu on 27/08/25.
//

import Foundation
import SwiftUI
import Combine

/// Main finance manager responsible for all financial operations and data management
/// Implements ObservableObject for SwiftUI integration and follows MVVM architecture
@MainActor
class FinanceManager: ObservableObject {
    // MARK: - Published Properties
    
    /// All financial transactions
    @Published var transactions: [Transaction] = []
    
    /// All financial accounts
    @Published var accounts: [Account] = []
    
    /// Budgets for different categories
    @Published var budgets: [Budget] = []
    
    /// Bills and subscriptions
    @Published var bills: [Bill] = []
    
    /// Savings goals
    @Published var savingsGoals: [SavingsGoal] = []
    
    /// Financial insights generated by AI
    @Published var insights: [FinancialInsight] = []
    
    /// Current finance summary
    @Published var summary: FinanceSummary?
    
    /// Loading state for async operations
    @Published var isLoading = false
    
    /// Error state for user feedback
    @Published var errorMessage: String?
    
    /// Recurring transactions
    @Published var recurringTransactions: [RecurringTransaction] = []
    
    /// Tax reports
    @Published var taxReports: [TaxReport] = []
    
    /// Shared account invitations
    @Published var sharedInvitations: [SharedAccountInvitation] = []
    
    /// Bank connections
    @Published var bankConnections: [BankConnection] = []
    
    /// Available currencies
    @Published var availableCurrencies: [Currency] = Currency.all
    
    /// Base currency for the app
    @Published var baseCurrency: Currency = .usd
    
    /// OCR processing state
    @Published var isOCRProcessing = false
    
    /// Bank sync state
    @Published var isBankSyncing = false

    // MARK: - Private Properties
    
    /// Combine cancellables for managing subscriptions
    private var cancellables = Set<AnyCancellable>()
    
    /// UserDefaults key for data persistence
    private let userDefaults = UserDefaults.standard
    
    /// Keys for UserDefaults storage
    private enum StorageKeys {
        static let transactions = "finance_transactions"
        static let accounts = "finance_accounts"
        static let budgets = "finance_budgets"
        static let bills = "finance_bills"
        static let savingsGoals = "finance_savings_goals"
        static let insights = "finance_insights"
        static let recurringTransactions = "finance_recurring_transactions"
        static let taxReports = "finance_tax_reports"
        static let sharedInvitations = "finance_shared_invitations"
        static let bankConnections = "finance_bank_connections"
        static let baseCurrency = "finance_base_currency"
    }
    
    /// Timer for processing recurring transactions
    private var recurringTransactionTimer: Timer?
    
    /// OCR processor for receipt scanning
    private let ocrProcessor = OCRProcessor()
    
    /// Bank sync service
    private let bankSyncService = BankSyncService()

    // MARK: - Initialization
    
    init() {
        // Initialize with error handling to prevent initialization failures
        do {
            try loadData()
            setupSubscriptions()
            generateInitialData()
            setupRecurringTransactionTimer()
        } catch {
            // Log error but don't crash the app
            print("FinanceManager initialization error: \(error)")
            // Set default values to ensure app continues to work
            setupDefaultValues()
        }
    }
    
    deinit {
        recurringTransactionTimer?.invalidate()
    }
    
    // MARK: - Default Values Setup
    
    /// Sets up default values when initialization fails
    private func setupDefaultValues() {
        transactions = []
        accounts = []
        budgets = []
        bills = []
        savingsGoals = []
        insights = []
        recurringTransactions = []
        taxReports = []
        sharedInvitations = []
        bankConnections = []
        availableCurrencies = Currency.all
        baseCurrency = .usd
        summary = FinanceSummary()
    }

    // MARK: - Data Loading & Persistence
    
    /// Loads all financial data from persistent storage
    private func loadData() throws {
        do {
            loadTransactions()
            loadAccounts()
            loadBudgets()
            loadBills()
            loadSavingsGoals()
            loadInsights()
            loadRecurringTransactions()
            loadTaxReports()
            loadSharedInvitations()
            loadBankConnections()
            loadBaseCurrency()
            updateSummary()
        } catch {
            print("Error loading finance data: \(error)")
            // Don't rethrow - let the caller handle it
            throw error
        }
    }
    
    /// Saves all financial data to persistent storage
    private func saveData() {
        saveTransactions()
        saveAccounts()
        saveBudgets()
        saveBills()
        saveSavingsGoals()
        saveInsights()
        saveRecurringTransactions()
        saveTaxReports()
        saveSharedInvitations()
        saveBankConnections()
        saveBaseCurrency()
    }

    // MARK: - Enhanced Transaction Management
    
    /// Adds a new transaction with OCR support
    /// - Parameter transaction: The transaction to add
    func addTransaction(_ transaction: Transaction) {
        transactions.append(transaction)
        updateAccountBalance(for: transaction)
        updateBudgets(for: transaction)
        generateInsights()
        saveData()
        updateSummary()
        
        // Process OCR data if available
        if let ocrData = transaction.ocrData {
            processOCRData(ocrData, for: transaction)
        }
        
        // Check for anomalies
        checkForAnomalies(in: transaction)
    }
    
    /// Updates an existing transaction
    /// - Parameter transaction: The updated transaction
    func updateTransaction(_ transaction: Transaction) {
        if let index = transactions.firstIndex(where: { $0.id == transaction.id }) {
            let oldTransaction = transactions[index]
            transactions[index] = transaction
            
            // Revert old transaction's impact
            updateAccountBalance(for: oldTransaction, isReversal: true)
            updateBudgets(for: oldTransaction, isReversal: true)
            
            // Apply new transaction's impact
            updateAccountBalance(for: transaction)
            updateBudgets(for: transaction)
            
            generateInsights()
            saveData()
            updateSummary()
        }
    }
    
    /// Deletes a transaction
    /// - Parameter transaction: The transaction to delete
    func deleteTransaction(_ transaction: Transaction) {
        transactions.removeAll { $0.id == transaction.id }
        updateAccountBalance(for: transaction, isReversal: true)
        updateBudgets(for: transaction, isReversal: true)
        generateInsights()
        saveData()
        updateSummary()
    }

    // MARK: - Multi-Currency Support
    
    /// Converts amount from one currency to another
    /// - Parameters:
    ///   - amount: The amount to convert
    ///   - from: Source currency
    ///   - to: Target currency
    /// - Returns: Converted amount in target currency
    func convertCurrency(_ amount: Decimal, from: Currency, to: Currency) -> Decimal {
        guard from.code != to.code else { return amount }
        
        // Convert to base currency first, then to target currency
        let baseAmount = amount * from.exchangeRate
        return baseAmount / to.exchangeRate
    }
    
    /// Updates exchange rates for all currencies
    func updateExchangeRates() async {
        // In a real app, this would fetch from a currency API
        // For now, we'll simulate rate updates
        for i in 0..<availableCurrencies.count {
            let randomChange = Double.random(in: -0.05...0.05)
            availableCurrencies[i].exchangeRate *= Decimal(1 + randomChange)
        }
        
        await MainActor.run {
            saveData()
            updateSummary()
        }
    }

    // MARK: - Budget Management
    
    /// Adds a new budget
    /// - Parameter budget: The budget to add
    func addBudget(_ budget: Budget) {
        budgets.append(budget)
        generateInsights()
        saveData()
        updateSummary()
    }
    
    /// Updates an existing budget
    /// - Parameter budget: The updated budget
    func updateBudget(_ budget: Budget) {
        if let index = budgets.firstIndex(where: { $0.id == budget.id }) {
            budgets[index] = budget
            generateInsights()
            saveData()
            updateSummary()
        }
    }
    
    /// Deletes a budget
    /// - Parameter budget: The budget to delete
    func deleteBudget(_ budget: Budget) {
        budgets.removeAll { $0.id == budget.id }
        generateInsights()
        saveData()
        updateSummary()
    }
    
    // MARK: - Bill Management
    
    /// Adds a new bill
    /// - Parameter bill: The bill to add
    func addBill(_ bill: Bill) {
        bills.append(bill)
        generateInsights()
        saveData()
        updateSummary()
    }
    
    /// Updates an existing bill
    /// - Parameter bill: The updated bill
    func updateBill(_ bill: Bill) {
        if let index = bills.firstIndex(where: { $0.id == bill.id }) {
            bills[index] = bill
            generateInsights()
            saveData()
            updateSummary()
        }
    }
    
    /// Deletes a bill
    /// - Parameter bill: The bill to delete
    func deleteBill(_ bill: Bill) {
        bills.removeAll { $0.id == bill.id }
        generateInsights()
        saveData()
        updateSummary()
    }
    
    /// Marks a bill as paid
    /// - Parameter bill: The bill to mark as paid
    func markBillAsPaid(_ bill: Bill) {
        if let index = bills.firstIndex(where: { $0.id == bill.id }) {
            bills[index].isPaid = true
            bills[index].paidDate = Date()
            generateInsights()
            saveData()
            updateSummary()
        }
    }
    
    // MARK: - Savings Goal Management
    
    /// Adds a new savings goal
    /// - Parameter goal: The savings goal to add
    func addSavingsGoal(_ goal: SavingsGoal) {
        savingsGoals.append(goal)
        generateInsights()
        saveData()
        updateSummary()
    }
    
    /// Updates an existing savings goal
    /// - Parameter goal: The updated savings goal
    func updateSavingsGoal(_ goal: SavingsGoal) {
        if let index = savingsGoals.firstIndex(where: { $0.id == goal.id }) {
            savingsGoals[index] = goal
            generateInsights()
            saveData()
            updateSummary()
        }
    }
    
    /// Deletes a savings goal
    /// - Parameter goal: The savings goal to delete
    func deleteSavingsGoal(_ goal: SavingsGoal) {
        savingsGoals.removeAll { $0.id == goal.id }
        generateInsights()
        saveData()
        updateSummary()
    }
    
    /// Adds a contribution to a savings goal
    /// - Parameters:
    ///   - goal: The savings goal to contribute to
    ///   - contribution: The contribution to add
    func addContribution(to goal: SavingsGoal, contribution: Contribution) {
        if let index = savingsGoals.firstIndex(where: { $0.id == goal.id }) {
            savingsGoals[index].contributions.append(contribution)
            savingsGoals[index].currentAmount += contribution.amount
            generateInsights()
            saveData()
            updateSummary()
        }
    }
    
    // MARK: - OCR Processing
    
    /// Processes receipt image with OCR
    /// - Parameter imageData: The receipt image data
    /// - Returns: OCR data with extracted information
    func processReceiptOCR(_ imageData: Data) async -> OCRData? {
        await MainActor.run {
            isOCRProcessing = true
        }
        
        defer {
            Task { @MainActor in
                isOCRProcessing = false
            }
        }
        
        // Simulate OCR processing
        try? await Task.sleep(nanoseconds: 2_000_000_000)
        
        // In a real app, this would use Vision framework for OCR
        let mockOCRData = OCRData(
            merchantName: "Sample Store",
            amount: Decimal(29.99),
            date: Date(),
            category: "Shopping",
            confidence: 0.85,
            rawText: "Sample Store\nTotal: $29.99\nDate: \(Date())"
        )
        
        return mockOCRData
    }
    
    /// Processes OCR data and applies to transaction
    /// - Parameters:
    ///   - ocrData: The OCR data to process
    ///   - transaction: The transaction to update
    private func processOCRData(_ ocrData: OCRData, for transaction: Transaction) {
        // Auto-categorize based on merchant name
        if let merchantName = ocrData.merchantName {
            let suggestedCategory = suggestCategory(for: merchantName)
            // Update transaction category if confidence is high
            if ocrData.confidence > 0.8 {
                // In a real app, you'd update the transaction here
            }
        }
    }
    
    /// Suggests category based on merchant name
    /// - Parameter merchantName: The merchant name to analyze
    /// - Returns: Suggested transaction category
    private func suggestCategory(for merchantName: String) -> TransactionCategory {
        let lowercased = merchantName.lowercased()
        
        if lowercased.contains("grocery") || lowercased.contains("food") {
            return TransactionCategory(name: "Food & Dining", iconName: "cart.fill", color: .orange)
        } else if lowercased.contains("gas") || lowercased.contains("fuel") {
            return TransactionCategory(name: "Transportation", iconName: "car.fill", color: .blue)
        } else if lowercased.contains("amazon") || lowercased.contains("walmart") {
            return TransactionCategory(name: "Shopping", iconName: "bag.fill", color: .purple)
        } else {
            return TransactionCategory(name: "Other", iconName: "questionmark.circle", color: .gray)
        }
    }

    // MARK: - Anomaly Detection
    
    /// Checks for anomalies in a transaction
    /// - Parameter transaction: The transaction to check
    private func checkForAnomalies(in transaction: Transaction) {
        let userSpendingPattern = getUserSpendingPattern(for: transaction.category)
        let isAnomaly = transaction.amount > userSpendingPattern.averageAmount * 3
        
        if isAnomaly {
            let insight = FinancialInsight(
                title: "Unusual Spending Detected",
                description: "Your \(transaction.category.name) spending of \(transaction.formattedAmount) is significantly higher than usual.",
                type: .anomaly,
                category: transaction.category.name,
                amount: transaction.amount,
                currency: transaction.currency,
                date: Date(),
                actionable: true,
                actionTitle: "Review",
                confidence: 0.9,
                tags: ["anomaly", "spending"],
                isRead: false,
                priority: .high
            )
            
            insights.append(insight)
            saveData()
        }
    }
    
    /// Gets user spending pattern for a category
    /// - Parameter category: The category to analyze
    /// - Returns: Spending pattern data
    private func getUserSpendingPattern(for category: TransactionCategory) -> SpendingPattern {
        let categoryTransactions = transactions.filter { $0.category.id == category.id }
        let amounts = categoryTransactions.map { $0.amount }
        
        let averageAmount = amounts.isEmpty ? 0 : amounts.reduce(0, +) / Decimal(amounts.count)
        let maxAmount = amounts.max() ?? 0
        
        return SpendingPattern(
            category: category,
            averageAmount: averageAmount,
            maxAmount: maxAmount,
            transactionCount: amounts.count
        )
    }

    // MARK: - Bank Sync
    
    /// Connects to a bank account
    /// - Parameter institutionId: The bank institution ID
    func connectBankAccount(institutionId: String) async {
        await MainActor.run {
            isBankSyncing = true
        }
        
        defer {
            Task { @MainActor in
                isBankSyncing = false
            }
        }
        
        // Simulate bank connection process
        try? await Task.sleep(nanoseconds: 3_000_000_000)
        
        let connection = BankConnection(
            institutionId: institutionId,
            accountId: UUID().uuidString,
            connectionStatus: .connected,
            lastSyncDate: Date(),
            requiresReauthorization: false
        )
        
        await MainActor.run {
            bankConnections.append(connection)
            saveData()
        }
    }
    
    /// Syncs bank account data
    /// - Parameter connection: The bank connection to sync
    func syncBankAccount(_ connection: BankConnection) async {
        // Simulate bank sync
        try? await Task.sleep(nanoseconds: 2_000_000_000)
        
        await MainActor.run {
            if let index = bankConnections.firstIndex(where: { $0.id == connection.id }) {
                bankConnections[index].lastSyncDate = Date()
                saveData()
            }
        }
    }

    // MARK: - Tax Reports
    
    /// Generates tax report for a specific year
    /// - Parameter year: The year to generate report for
    /// - Returns: Generated tax report
    func generateTaxReport(for year: Int) -> TaxReport {
        let yearTransactions = transactions.filter { 
            Calendar.current.component(.year, from: $0.date) == year 
        }
        
        let income = yearTransactions
            .filter { $0.type == .income }
            .reduce(0) { $0 + $1.amount }
        
        let expenses = yearTransactions
            .filter { $0.type == .expense }
            .reduce(0) { $0 + $1.amount }
        
        let deductibleExpenses = yearTransactions
            .filter { $0.type == .expense && $0.category.name == "Business" }
            .reduce(0) { $0 + $1.amount }
        
        let netIncome = income - expenses
        
        let categorySummaries = Dictionary(grouping: yearTransactions) { $0.category.name }
            .map { category, transactions in
                CategorySummary(
                    category: category,
                    totalAmount: transactions.reduce(0) { $0 + $0.amount },
                    transactionCount: transactions.count,
                    isDeductible: category == "Business"
                )
            }
        
        let report = TaxReport(
            year: year,
            totalIncome: income,
            totalExpenses: expenses,
            deductibleExpenses: deductibleExpenses,
            netIncome: netIncome,
            currency: baseCurrency,
            categories: categorySummaries,
            generatedDate: Date(),
            isExported: false
        )
        
        taxReports.append(report)
        saveData()
        
        return report
    }

    // MARK: - Shared Accounts
    
    /// Invites a user to share an account
    /// - Parameters:
    ///   - accountId: The account to share
    ///   - email: The email to invite
    ///   - permissions: The permissions to grant
    func inviteUserToAccount(accountId: String, email: String, permissions: [PermissionType]) {
        let invitation = SharedAccountInvitation(
            accountId: accountId,
            invitedEmail: email,
            invitedBy: "current_user", // In real app, get from user session
            permissions: permissions,
            status: .pending,
            sentDate: Date(),
            expiresDate: Calendar.current.date(byAdding: .day, value: 7, to: Date()) ?? Date()
        )
        
        sharedInvitations.append(invitation)
        saveData()
        
        // In a real app, send email invitation here
    }
    
    /// Accepts a shared account invitation
    /// - Parameter invitationId: The invitation to accept
    func acceptSharedInvitation(_ invitationId: String) {
        if let index = sharedInvitations.firstIndex(where: { $0.id.uuidString == invitationId }) {
            sharedInvitations[index].status = .accepted
            saveData()
        }
    }

    // MARK: - Recurring Transactions
    
    /// Sets up recurring transaction timer
    private func setupRecurringTransactionTimer() {
        recurringTransactionTimer = Timer.scheduledTimer(withTimeInterval: 3600, repeats: true) { _ in
            Task { @MainActor in
                self.processRecurringTransactions()
            }
        }
    }
    
    /// Sets up subscriptions and notifications
    private func setupSubscriptions() {
        // Setup any necessary subscriptions for real-time updates
        // This could include bank connection updates, market data, etc.
        // For now, this is a placeholder for future implementation
    }
    
    /// Generates initial sample data for the app
    private func generateInitialData() {
        // Only generate initial data if no data exists
        guard transactions.isEmpty && accounts.isEmpty else { return }
        
        // Create sample accounts
        let sampleAccounts = [
            Account(name: "Main Checking", type: .checking, balance: 5000.0, currency: .usd, accountNumber: nil, routingNumber: nil, institution: nil, isShared: false, sharedWith: nil, permissions: [], bankConnection: nil, lastSyncDate: nil, isActive: true),
            Account(name: "Savings", type: .savings, balance: 15000.0, currency: .usd, accountNumber: nil, routingNumber: nil, institution: nil, isShared: false, sharedWith: nil, permissions: [], bankConnection: nil, lastSyncDate: nil, isActive: true),
            Account(name: "Credit Card", type: .creditCard, balance: -2500.0, currency: .usd, accountNumber: nil, routingNumber: nil, institution: nil, isShared: false, sharedWith: nil, permissions: [], bankConnection: nil, lastSyncDate: nil, isActive: true)
        ]
        
        accounts = sampleAccounts
        
        // Create sample transactions
        let sampleTransactions = [
            Transaction(amount: 1200.0, type: .income, category: TransactionCategory(name: "Salary", iconName: "dollarsign.circle", color: .green), merchant: "Company Inc", date: Date(), account: sampleAccounts[0], notes: "Monthly salary", receiptImageData: nil, location: nil, priority: .medium, isRecurring: false, recurringInterval: nil, tags: [], currency: .usd, ocrData: nil, isAnomaly: false, sharedWith: nil),
            Transaction(amount: 85.50, type: .expense, category: TransactionCategory(name: "Food & Dining", iconName: "fork.knife", color: .orange), merchant: "Grocery Store", date: Date().addingTimeInterval(-86400), account: sampleAccounts[0], notes: "Weekly groceries", receiptImageData: nil, location: nil, priority: .medium, isRecurring: false, recurringInterval: nil, tags: [], currency: .usd, ocrData: nil, isAnomaly: false, sharedWith: nil),
            Transaction(amount: 45.00, type: .expense, category: TransactionCategory(name: "Transportation", iconName: "car.fill", color: .blue), merchant: "Gas Station", date: Date().addingTimeInterval(-172800), account: sampleAccounts[0], notes: "Fuel", receiptImageData: nil, location: nil, priority: .medium, isRecurring: false, recurringInterval: nil, tags: [], currency: .usd, ocrData: nil, isAnomaly: false, sharedWith: nil)
        ]
        
        transactions = sampleTransactions
        
        // Create sample budgets
        let sampleBudgets = [
            Budget(name: "Food & Dining", category: TransactionCategory(name: "Food & Dining", iconName: "fork.knife", color: .orange), amount: 500.0, currency: .usd, period: .monthly, startDate: Date(), endDate: Calendar.current.date(byAdding: .month, value: 1, to: Date()) ?? Date(), spent: 85.50, isShared: false, sharedWith: nil, aiSuggestions: [], isActive: true),
            Budget(name: "Transportation", category: TransactionCategory(name: "Transportation", iconName: "car.fill", color: .blue), amount: 200.0, currency: .usd, period: .monthly, startDate: Date(), endDate: Calendar.current.date(byAdding: .month, value: 1, to: Date()) ?? Date(), spent: 45.00, isShared: false, sharedWith: nil, aiSuggestions: [], isActive: true),
            Budget(name: "Entertainment", category: TransactionCategory(name: "Entertainment", iconName: "gamecontroller", color: .purple), amount: 300.0, currency: .usd, period: .monthly, startDate: Date(), endDate: Calendar.current.date(byAdding: .month, value: 1, to: Date()) ?? Date(), spent: 0.0, isShared: false, sharedWith: nil, aiSuggestions: [], isActive: true)
        ]
        
        budgets = sampleBudgets
        
        // Save the initial data
        saveData()
        updateSummary()
    }
    
    /// Processes recurring transactions
    private func processRecurringTransactions() {
        let now = Date()
        
        for recurring in recurringTransactions where recurring.isActive {
            if recurring.nextRunDate <= now {
                createTransactionFromRecurring(recurring)
                updateNextRunDate(for: recurring)
            }
        }
    }
    
    /// Creates transaction from recurring template
    /// - Parameter recurring: The recurring transaction template
    private func createTransactionFromRecurring(_ recurring: RecurringTransaction) {
        let transaction = Transaction(
            amount: recurring.amount,
            type: recurring.type,
            category: recurring.category,
            merchant: recurring.name,
            date: Date(),
            account: recurring.account,
            notes: recurring.notes,
            receiptImageData: nil,
            location: nil,
            priority: .medium,
            isRecurring: true,
            recurringInterval: recurring.interval,
            tags: [],
            currency: recurring.currency,
            ocrData: nil,
            isAnomaly: false,
            sharedWith: nil
        )
        
        addTransaction(transaction)
    }
    
    /// Updates next run date for recurring transaction
    /// - Parameter recurring: The recurring transaction to update
    private func updateNextRunDate(for recurring: RecurringTransaction) {
        if let index = recurringTransactions.firstIndex(where: { $0.id == recurring.id }) {
            let nextDate = calculateNextRunDate(for: recurring)
            recurringTransactions[index].nextRunDate = nextDate
            recurringTransactions[index].lastRunDate = Date()
            recurringTransactions[index].totalRuns += 1
            
            // Check if max runs reached
            if let maxRuns = recurring.maxRuns,
               recurringTransactions[index].totalRuns >= maxRuns {
                recurringTransactions[index].isActive = false
            }
            
            saveData()
        }
    }
    
    /// Calculates next run date for recurring transaction
    /// - Parameter recurring: The recurring transaction
    /// - Returns: Next run date
    private func calculateNextRunDate(for recurring: RecurringTransaction) -> Date {
        let calendar = Calendar.current
        let now = Date()
        
        switch recurring.interval {
        case .daily:
            return calendar.date(byAdding: .day, value: 1, to: now) ?? now
        case .weekly:
            return calendar.date(byAdding: .weekOfYear, value: 1, to: now) ?? now
        case .biweekly:
            return calendar.date(byAdding: .weekOfYear, value: 2, to: now) ?? now
        case .monthly:
            return calendar.date(byAdding: .month, value: 1, to: now) ?? now
        case .quarterly:
            return calendar.date(byAdding: .month, value: 3, to: now) ?? now
        case .yearly:
            return calendar.date(byAdding: .year, value: 1, to: now) ?? now
        case .custom:
            return now // Custom logic would be implemented here
        }
    }

    // MARK: - AI Insights & Forecasting
    
    /// Generates comprehensive financial insights
    private func generateInsights() {
        insights.removeAll()
        
        // Spending insights
        generateSpendingInsights()
        
        // Budget insights
        generateBudgetInsights()
        
        // Savings insights
        generateSavingsInsights()
        
        // Cash flow forecast
        generateCashFlowForecast()
        
        // Net worth forecast
        generateNetWorthForecast()
        
        saveData()
    }
    
    /// Generates spending pattern insights
    private func generateSpendingInsights() {
        let categorySpending = Dictionary(grouping: transactions) { $0.category.name }
        
        for (category, transactions) in categorySpending {
            let total = transactions.reduce(0) { $0 + $0.amount }
            let average = total / Decimal(transactions.count)
            
            if total > 1000 { // High spending threshold
                let insight = FinancialInsight(
                    title: "High Spending in \(category)",
                    description: "You've spent \(total.formatted(.currency(code: baseCurrency.code))) in \(category) this month.",
                    type: .spending,
                    category: category,
                    amount: total,
                    currency: baseCurrency,
                    date: Date(),
                    actionable: true,
                    actionTitle: "Set Budget",
                    confidence: 0.8,
                    tags: ["spending", "budget"],
                    isRead: false,
                    priority: .medium
                )
                insights.append(insight)
            }
        }
    }
    
    /// Generates budget-related insights
    private func generateBudgetInsights() {
        for budget in budgets where budget.isActive {
            if budget.spendingPercentage > 0.8 {
                let insight = FinancialInsight(
                    title: "Budget Alert: \(budget.name)",
                    description: "You've used \(Int(truncating: budget.spendingPercentage * 100 as NSNumber))% of your \(budget.name) budget.",
                    type: .budget,
                    category: budget.category.name,
                    amount: budget.spent,
                    currency: budget.currency,
                    date: Date(),
                    actionable: true,
                    actionTitle: "Review Budget",
                    confidence: 0.9,
                    tags: ["budget", "alert"],
                    isRead: false,
                    priority: .high
                )
                insights.append(insight)
            }
        }
    }
    
    /// Generates savings goal insights
    private func generateSavingsInsights() {
        for goal in savingsGoals where goal.isActive {
            if let forecast = goal.aiForecast {
                let insight = FinancialInsight(
                    title: "Savings Goal: \(goal.name)",
                    description: "You're on track to reach your goal by \(forecast.estimatedCompletionDate.formatted(date: .abbreviated, time: .omitted)).",
                    type: .forecast,
                    category: "Savings",
                    amount: goal.currentAmount,
                    currency: goal.currency,
                    date: Date(),
                    actionable: false,
                    confidence: forecast.confidence,
                    tags: ["savings", "forecast"],
                    isRead: false,
                    priority: .low
                )
                insights.append(insight)
            }
        }
    }
    
    /// Generates cash flow forecast
    private func generateCashFlowForecast() {
        let nextMonth = Calendar.current.date(byAdding: .month, value: 1, to: Date()) ?? Date()
        let predictedIncome = summary?.monthlyIncome ?? 0 * 1.05 // 5% growth assumption
        let predictedExpenses = summary?.monthlyExpenses ?? 0 * 1.02 // 2% growth assumption
        let predictedSavings = predictedIncome - predictedExpenses
        
        let forecast = CashFlowForecast(
            period: .oneMonth,
            predictedIncome: predictedIncome,
            predictedExpenses: predictedExpenses,
            predictedSavings: predictedSavings,
            confidence: 0.75,
            factors: ["Historical trends", "Seasonal patterns"],
            lastUpdated: Date()
        )
        
        // Update summary with forecast
        if summary != nil {
            summary?.cashFlowForecast = forecast
        }
    }
    
    /// Generates net worth forecast
    private func generateNetWorthForecast() {
        let currentNetWorth = summary?.netWorth ?? 0
        let monthlyGrowth = (summary?.monthlySavings ?? 0) * 12
        let predictedNetWorth = currentNetWorth + monthlyGrowth
        
        let forecast = NetWorthForecast(
            targetDate: Calendar.current.date(byAdding: .year, value: 1, to: Date()) ?? Date(),
            predictedNetWorth: predictedNetWorth,
            confidence: 0.7,
            growthRate: monthlyGrowth / currentNetWorth,
            factors: ["Monthly savings", "Investment returns"],
            lastUpdated: Date()
        )
        
        // Update summary with forecast
        if summary != nil {
            summary?.netWorthForecast = forecast
        }
    }

    // MARK: - Data Persistence Methods
    
    /// Loads transactions from storage
    private func loadTransactions() {
        if let data = userDefaults.data(forKey: StorageKeys.transactions),
           let decoded = try? JSONDecoder().decode([Transaction].self, from: data) {
            transactions = decoded
        }
    }
    
    /// Saves transactions to storage
    private func saveTransactions() {
        if let encoded = try? JSONEncoder().encode(transactions) {
            userDefaults.set(encoded, forKey: StorageKeys.transactions)
        }
    }
    
    /// Loads accounts from storage
    private func loadAccounts() {
        if let data = userDefaults.data(forKey: StorageKeys.accounts),
           let decoded = try? JSONDecoder().decode([Account].self, from: data) {
            accounts = decoded
        }
    }
    
    /// Saves accounts to storage
    private func saveAccounts() {
        if let encoded = try? JSONEncoder().encode(accounts) {
            userDefaults.set(encoded, forKey: StorageKeys.accounts)
        }
    }
    
    /// Loads budgets from storage
    private func loadBudgets() {
        if let data = userDefaults.data(forKey: StorageKeys.budgets),
           let decoded = try? JSONDecoder().decode([Budget].self, from: data) {
            budgets = decoded
        }
    }
    
    /// Saves budgets to storage
    private func saveBudgets() {
        if let encoded = try? JSONEncoder().encode(budgets) {
            userDefaults.set(encoded, forKey: StorageKeys.budgets)
        }
    }
    
    /// Loads bills from storage
    private func loadBills() {
        if let data = userDefaults.data(forKey: StorageKeys.bills),
           let decoded = try? JSONDecoder().decode([Bill].self, from: data) {
            bills = decoded
        }
    }
    
    /// Saves bills to storage
    private func saveBills() {
        if let encoded = try? JSONEncoder().encode(bills) {
            userDefaults.set(encoded, forKey: StorageKeys.bills)
        }
    }
    
    /// Loads savings goals from storage
    private func loadSavingsGoals() {
        if let data = userDefaults.data(forKey: StorageKeys.savingsGoals),
           let decoded = try? JSONDecoder().decode([SavingsGoal].self, from: data) {
            savingsGoals = decoded
        }
    }
    
    /// Saves savings goals to storage
    private func saveSavingsGoals() {
        if let encoded = try? JSONEncoder().encode(savingsGoals) {
            userDefaults.set(encoded, forKey: StorageKeys.savingsGoals)
        }
    }
    
    /// Loads insights from storage
    private func loadInsights() {
        if let data = userDefaults.data(forKey: StorageKeys.insights),
           let decoded = try? JSONDecoder().decode([FinancialInsight].self, from: data) {
            insights = decoded
        }
    }
    
    /// Saves insights to storage
    private func saveInsights() {
        if let encoded = try? JSONEncoder().encode(insights) {
            userDefaults.set(encoded, forKey: StorageKeys.insights)
        }
    }
    
    /// Loads recurring transactions from storage
    private func loadRecurringTransactions() {
        if let data = userDefaults.data(forKey: StorageKeys.recurringTransactions),
           let decoded = try? JSONDecoder().decode([RecurringTransaction].self, from: data) {
            recurringTransactions = decoded
        }
    }
    
    /// Saves recurring transactions to storage
    private func saveRecurringTransactions() {
        if let encoded = try? JSONEncoder().encode(recurringTransactions) {
            userDefaults.set(encoded, forKey: StorageKeys.recurringTransactions)
        }
    }
    
    /// Loads tax reports from storage
    private func loadTaxReports() {
        if let data = userDefaults.data(forKey: StorageKeys.taxReports),
           let decoded = try? JSONDecoder().decode([TaxReport].self, from: data) {
            taxReports = decoded
        }
    }
    
    /// Saves tax reports to storage
    private func saveTaxReports() {
        if let encoded = try? JSONEncoder().encode(taxReports) {
            userDefaults.set(encoded, forKey: StorageKeys.taxReports)
        }
    }
    
    /// Loads shared invitations from storage
    private func loadSharedInvitations() {
        if let data = userDefaults.data(forKey: StorageKeys.sharedInvitations),
           let decoded = try? JSONDecoder().decode([SharedAccountInvitation].self, from: data) {
            sharedInvitations = decoded
        }
    }
    
    /// Saves shared invitations to storage
    private func saveSharedInvitations() {
        if let encoded = try? JSONEncoder().encode(sharedInvitations) {
            userDefaults.set(encoded, forKey: StorageKeys.sharedInvitations)
        }
    }
    
    /// Loads bank connections from storage
    private func loadBankConnections() {
        if let data = userDefaults.data(forKey: StorageKeys.bankConnections),
           let decoded = try? JSONDecoder().decode([BankConnection].self, from: data) {
            bankConnections = decoded
        }
    }
    
    /// Saves bank connections to storage
    private func saveBankConnections() {
        if let encoded = try? JSONEncoder().encode(bankConnections) {
            userDefaults.set(encoded, forKey: StorageKeys.bankConnections)
        }
    }
    
    /// Loads base currency from storage
    private func loadBaseCurrency() {
        if let data = userDefaults.data(forKey: StorageKeys.baseCurrency),
           let decoded = try? JSONDecoder().decode(Currency.self, from: data) {
            baseCurrency = decoded
        }
    }
    
    /// Saves base currency to storage
    private func saveBaseCurrency() {
        if let encoded = try? JSONEncoder().encode(baseCurrency) {
            userDefaults.set(encoded, forKey: StorageKeys.baseCurrency)
        }
    }
    
    // MARK: - Summary Management
    
    /// Updates the finance summary with current data
    private func updateSummary() {
        let totalBalance = accounts.reduce(0) { $0 + $1.balance }
        let totalIncome = transactions.filter { $0.type == .income }.reduce(0) { $0 + $0.amount }
        let totalExpenses = transactions.filter { $0.type == .expense }.reduce(0) { $0 + $0.amount }
        let totalSavings = savingsGoals.reduce(0) { $0 + $0.currentAmount }
        
        summary = FinanceSummary(
            totalBalance: totalBalance,
            totalIncome: totalIncome,
            totalExpenses: totalExpenses,
            totalSavings: totalSavings,
            accountCount: accounts.count,
            transactionCount: transactions.count,
            budgetCount: budgets.count,
            lastUpdated: Date()
        )
    }
    
    // MARK: - Account and Budget Updates
    
    /// Updates account balance when a transaction occurs
    /// - Parameters:
    ///   - transaction: The transaction affecting the account
    ///   - isReversal: Whether this is reversing a previous transaction
    private func updateAccountBalance(for transaction: Transaction, isReversal: Bool = false) {
        guard let accountIndex = accounts.firstIndex(where: { $0.id == transaction.account.id }) else { return }
        
        let multiplier: Decimal = isReversal ? -1 : 1
        let amount = transaction.amount * multiplier
        
        switch transaction.type {
        case .income:
            accounts[accountIndex].balance += amount
        case .expense:
            accounts[accountIndex].balance -= amount
        case .transfer:
            // Handle transfer logic if needed
            break
        }
    }
    
    /// Updates budget when a transaction occurs
    /// - Parameters:
    ///   - transaction: The transaction affecting the budget
    ///   - isReversal: Whether this is reversing a previous transaction
    private func updateBudgets(for transaction: Transaction, isReversal: Bool = false) {
        guard transaction.type == .expense else { return }
        
        let multiplier: Decimal = isReversal ? -1 : 1
        let amount = transaction.amount * multiplier
        
        // Find and update relevant budget
        if let budgetIndex = budgets.firstIndex(where: { $0.category == transaction.category }) {
            budgets[budgetIndex].spentAmount += amount
        }
    }

    // MARK: - Public Interface Methods
    
    /// Refreshes all finance data
    func refreshData() {
        updateSummary()
        generateInsights()
        saveData()
    }
    
    /// Exports data in specified format
    /// - Parameters:
    ///   - format: The export format
    ///   - data: The data to export
    /// - Returns: Export data
    func exportData(format: ExportFormat, data: [Transaction]) -> Data? {
        switch format {
        case .csv:
            return exportToCSV(data)
        case .pdf:
            return exportToPDF(data)
        case .json:
            return exportToJSON(data)
        }
    }
    
    /// Exports transactions to CSV format
    /// - Parameter transactions: Transactions to export
    /// - Returns: CSV data
    private func exportToCSV(_ transactions: [Transaction]) -> Data? {
        var csvString = "Date,Merchant,Category,Amount,Type,Account,Notes\n"
        
        for transaction in transactions {
            let row = "\(transaction.formattedDate),\(transaction.merchant),\(transaction.category.name),\(transaction.amount),\(transaction.type.rawValue),\(transaction.account.name),\(transaction.notes ?? "")\n"
            csvString += row
        }
        
        return csvString.data(using: .utf8)
    }
    
    /// Exports transactions to PDF format
    /// - Parameter transactions: Transactions to export
    /// - Returns: PDF data
    private func exportToPDF(_ transactions: [Transaction]) -> Data? {
        // In a real app, this would generate a proper PDF
        // For now, return mock data
        return "PDF Export".data(using: .utf8)
    }
    
    /// Exports transactions to JSON format
    /// - Parameter transactions: Transactions to export
    /// - Returns: JSON data
    private func exportToJSON(_ transactions: [Transaction]) -> Data? {
        return try? JSONEncoder().encode(transactions)
    }
}

// MARK: - Supporting Classes

/// OCR processor for receipt scanning
class OCRProcessor {
    /// Processes image data with OCR
    /// - Parameter imageData: The image data to process
    /// - Returns: OCR results
    func processImage(_ imageData: Data) async -> OCRData? {
        // In a real app, this would use Vision framework
        // For now, return nil
        return nil
    }
}

/// Bank sync service for account connections
class BankSyncService {
    /// Connects to a bank institution
    /// - Parameter institutionId: The institution ID
    /// - Returns: Connection result
    func connectToInstitution(_ institutionId: String) async -> BankConnection? {
        // In a real app, this would handle OAuth flow
        // For now, return nil
        return nil
    }
}

/// Spending pattern data structure
struct SpendingPattern {
    let category: TransactionCategory
    let averageAmount: Decimal
    let maxAmount: Decimal
    let transactionCount: Int
}

// MARK: - Extensions

extension Calendar {
    /// Returns the start of the month for a given date
    /// - Parameter date: The date to get the start of month for
    /// - Returns: The start of the month date
    func startOfMonth(for date: Date) -> Date {
        let components = dateComponents([.year, .month], from: date)
        return Calendar.current.date(from: components) ?? date
    }
}

// MARK: - Haptic Manager

/// Manages haptic feedback throughout the app
class HapticManager {
    static let shared = HapticManager()
    
    private init() {}
    
    func success() {
        let impactFeedback = UIImpactFeedbackGenerator(style: .light)
        impactFeedback.impactOccurred()
    }
    
    func error() {
        let impactFeedback = UINotificationFeedbackGenerator()
        impactFeedback.notificationOccurred(.error)
    }
    
    func warning() {
        let impactFeedback = UINotificationFeedbackGenerator()
        impactFeedback.notificationOccurred(.warning)
    }
} 